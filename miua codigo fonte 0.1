89% de armazenamento usado … Se você ficar sem espaço, não poderá salvar arquivos no Drive, fazer backup no Google Fotos nem usar o Gmail. Aproveite 30 GB de armazenamento por R$ 4,50 R$ 1,00 durante um mês.
import random
import pygame
import os

# --- 1. Inicialização e Configuração Básica do Pygame ---
pygame.init()

LARGURA, ALTURA = 800, 600
TELA = pygame.display.set_mode((LARGURA, ALTURA))
pygame.display.set_caption("MIAUPOWWWWW")

# --- 2. Carregamento de Recursos (Imagens, Fontes) ---
base_path = os.path.dirname(os.path.abspath(__file__))
images_path = os.path.join(base_path, "images")

# Dicionário com nomes dos arquivos de imagem
arquivos_imagens = {
    "pedra_branco": "pedra.png",
    "pedra_cinza": "pedracinza.png",
    "papel_branco": "papel.png",
    "papel_cinza": "papelcinza.png",
    "tesoura_branco": "tesoura.png",
    "tesoura_cinza": "tesouracinza.png"
}

IMAGENS = {}
try:
    for chave, nome_arquivo in arquivos_imagens.items():
        caminho_imagem = os.path.join(images_path, nome_arquivo)
        if not os.path.exists(caminho_imagem):
            raise FileNotFoundError(f"Arquivo de imagem não encontrado: {caminho_imagem}")
        IMAGENS[chave] = pygame.image.load(caminho_imagem).convert_alpha() # .convert_alpha() para melhor desempenho
except FileNotFoundError as e:
    print(f"Erro: {e}")
    pygame.quit()
    exit()
except pygame.error as e:
    print(f"Erro ao carregar imagens: {e}")
    pygame.quit()
    exit()

# Fontes
fonte = pygame.font.SysFont(None, 36)
fonte_pequena = pygame.font.SysFont(None, 24)
fonte_grande = pygame.font.SysFont(None, 48) # Nova fonte para títulos maiores

# --- 3. Variáveis de Estado do Jogo (Globals, para simplificar por enquanto) ---
# Em um jogo maior, você poderia usar classes ou objetos para gerenciar o estado
opcoes = ["pedra", "papel", "tesoura"]

teclas_jogador1 = {
    pygame.K_a: "pedra",
    pygame.K_s: "papel",
    pygame.K_d: "tesoura"
}

teclas_jogador2 = {
    pygame.K_LEFT: "pedra",
    pygame.K_UP: "papel",
    pygame.K_RIGHT: "tesoura"
}

# Cartas especiais (DEFINA SUAS CARTAS AQUI COM DETALHES DE DURAÇÃO)
# Mapeamento para nomes amigáveis para HUD
NOME_CARTAS_AMIGAVEL = {
    "jogada_hacker": "Jogada do Hacker",
    "oitava_vida": "A Oitava Vida", # Renomeado para seguir sua ideia
    "miuadicao": "Miuadição",       # Adicionado, se for usar
    "garra_feroz": "Garra Feroz",
    "carta_nulo": "Carta Nula",     # Adicionado, se for usar
    "pata_leve": "Pata Leve",       # Minha sugestão
    "arranhao_sorte": "Arranhão da Sorte" # Sua nova carta!
}

# Definição das cartas com suas propriedades (duração)
# Isso permite que você adicione novas cartas facilmente.
# Para a 'Oitava Vida', que é de uso único, a duração será 0 ou não terá campo de duração se for ativada e consumida.
# Para "Carta Nulo", a duração é "1 partida" - precisaremos de lógica específica.
CARTAS_PROPRIEDADES = {
    "jogada_hacker": {"duração": 1}, # Ativa no próximo turno do oponente (1 turno de bloqueio)
    "oitava_vida": {"efeito": "recupera_vida"}, # Ação imediata, não tem duração de efeito
    "miuadicao": {"duração": 2}, # Bloqueia uma jogada por 2 turnos
    "garra_feroz": {"duração": 1}, # Efeito para a próxima rodada
    "carta_nulo": {"duração": "partida"}, # Bloqueia outras cartas na partida
    "pata_leve": {"duração": 0}, # Efeito imediato de troca de jogada
    "arranhao_sorte": {"duração": 2} # Invencibilidade secreta por 2 turnos
}


cartas_disponiveis_para_sorteio = list(CARTAS_PROPRIEDADES.keys()) # Lista de todas as cartas

# Estado global do jogo
estado_jogo = {
    "vidas": {"jogador1": 7, "jogador2": 7},
    "rodada": 1,
    "MAX_PARTIDAS": 13,
    "modo": None, # 'menu', 'cpu', 'local', 'resultado_rodada', 'fim_jogo'
    "jogada_jogador1": None,
    "jogada_jogador2": None,
    "mostrar_jogadas": False,
    "mostrar_jogadas_tempo": 0,
    "mensagem_tela": "Escolha o modo: 1 - Jogar contra CPU | 2 - Jogar Local",
    "vencedor_final": None,
    "cartas_jogador1": [],
    "cartas_jogador2": [],
    "efeitos_ativos": {"jogador1": {}, "jogador2": {}}, # {carta: {duração: X, ...}}
    "mao_invencivel_j1": None, # Para Arranhão da Sorte
    "mao_invencivel_j2": None  # Para Arranhão da Sorte
}

# --- 4. Funções de Desenho (Renderização) ---

def desenhar_menu(estado):
    TELA.fill((255, 255, 255))
    titulo = fonte_grande.render("MIAUPOWWW", True, (0, 0, 0))
    instrucao = fonte.render(estado["mensagem_tela"], True, (0, 0, 0))
    TELA.blit(titulo, (LARGURA // 2 - titulo.get_width() // 2, ALTURA // 3))
    TELA.blit(instrucao, (LARGURA // 2 - instrucao.get_width() // 2, ALTURA // 3 + 70))
    pygame.display.update()

def desenhar_hud(estado):
    # Texto Rodada e Vidas
    texto_rodada = fonte.render(f"Rodada: {estado['rodada']}/{estado['MAX_PARTIDAS']}", True, (0, 0, 0))
    texto_vidas = fonte.render(f"Vidas P1: {estado['vidas']['jogador1']} | Vidas P2: {estado['vidas']['jogador2']}", True, (0, 0, 0))
    TELA.blit(texto_rodada, (LARGURA // 2 - texto_rodada.get_width() // 2, 20))
    TELA.blit(texto_vidas, (LARGURA // 2 - texto_vidas.get_width() // 2, 60))

    # Instruções de Teclas
    instrucao_teclas_j1 = fonte_pequena.render("P1: A-Pedra S-Papel D-Tesoura", True, (0, 0, 0))
    instrucao_teclas_j2 = fonte_pequena.render("P2: ←-Pedra ↑-Papel →-Tesoura", True, (0, 0, 0))
    instrucao_cartas_j1 = fonte_pequena.render("P1 Carta: Q", True, (0, 0, 0))
    instrucao_cartas_j2 = fonte_pequena.render("P2 Carta: M", True, (0, 0, 0))

    TELA.blit(instrucao_teclas_j1, (20, ALTURA - 80))
    TELA.blit(instrucao_teclas_j2, (LARGURA - instrucao_teclas_j2.get_width() - 20, ALTURA - 80))
    TELA.blit(instrucao_cartas_j1, (20, ALTURA - 50))
    TELA.blit(instrucao_cartas_j2, (LARGURA - instrucao_cartas_j2.get_width() - 20, ALTURA - 50))


    # Mostrar cartas disponíveis na mão
    texto_cartas1 = fonte_pequena.render("Cartas P1: " + ", ".join([NOME_CARTAS_AMIGAVEL.get(c, c) for c in estado["cartas_jogador1"]]), True, (0, 0, 0))
    texto_cartas2 = fonte_pequena.render("Cartas P2: " + ", ".join([NOME_CARTAS_AMIGAVEL.get(c, c) for c in estado["cartas_jogador2"]]), True, (0, 0, 0))
    TELA.blit(texto_cartas1, (20, 100))
    TELA.blit(texto_cartas2, (LARGURA - texto_cartas2.get_width() - 20, 100))


    # Mostrar efeitos ativos (opcional, para depuração ou informação)
    # text_efeitos_j1 = fonte_pequena.render(f"Efeitos P1: {estado['efeitos_ativos']['jogador1']}", True, (0,0,0))
    # text_efeitos_j2 = fonte_pequena.render(f"Efeitos P2: {estado['efeitos_ativos']['jogador2']}", True, (0,0,0))
    # TELA.blit(text_efeitos_j1, (20, 130))
    # TELA.blit(text_efeitos_j2, (LARGURA - text_efeitos_j2.get_width() - 20, 130))


def desenhar_jogadas_no_jogo(estado):
    # Desenha as imagens das jogadas escolhidas
    if estado["jogada_jogador1"]:
        img_j1 = IMAGENS[estado["jogada_jogador1"] + "_branco"]
        TELA.blit(img_j1, (LARGURA // 4 - img_j1.get_width() // 2, ALTURA // 2 - img_j1.get_height() // 2))

    if estado["jogada_jogador2"]:
        img_j2 = IMAGENS[estado["jogada_jogador2"] + "_cinza"]
        TELA.blit(img_j2, (LARGURA * 3 // 4 - img_j2.get_width() // 2, ALTURA // 2 - img_j2.get_height() // 2))

def desenhar_tela_fim_jogo(estado):
    TELA.fill((255, 255, 255))
    texto = fonte_grande.render(f"{estado['vencedor_final'].upper()} VENCEU!", True, (0, 0, 0))
    instrucao = fonte.render("Pressione R para reiniciar ou ESC para sair.", True, (0, 0, 0))
    TELA.blit(texto, (LARGURA // 2 - texto.get_width() // 2, ALTURA // 2 - 50))
    TELA.blit(instrucao, (LARGURA // 2 - instrucao.get_width() // 2, ALTURA // 2 + 10))
    pygame.display.update()

# --- 5. Funções de Lógica do Jogo ---

def sortear_carta():
    """Retorna uma carta aleatória das disponíveis para sorteio."""
    return random.choice(cartas_disponiveis_para_sorteio)

def aplicar_efeito_carta(jogador, carta_nome):
    """
    Aplica o efeito de uma carta específica ao jogador.
    Gerencia a duração do efeito na `efeitos_ativos`.
    """
    global estado_jogo

    propriedades = CARTAS_PROPRIEDADES.get(carta_nome)
    if not propriedades:
        print(f"Erro: Carta '{carta_nome}' não encontrada nas propriedades.")
        return

    # Efeitos de duração de turno
    if "duração" in propriedades and isinstance(propriedades["duração"], int):
        estado_jogo["efeitos_ativos"][jogador][carta_nome] = {"duracao_restante": propriedades["duração"]}
        print(f"{jogador} ativou {NOME_CARTAS_AMIGAVEL[carta_nome]}! Duração: {propriedades['duração']} turnos.")
        if carta_nome == "arranhao_sorte":
            mao_invencivel = random.choice(opcoes)
            if jogador == "jogador1":
                estado_jogo["mao_invencivel_j1"] = mao_invencivel
            else:
                estado_jogo["mao_invencivel_j2"] = mao_invencivel
            print(f"Arranhão da Sorte ativado! Mão invencível secreta: {mao_invencivel} (para debug)") # REMOVER PARA PROD

    # Efeitos de uso único ou especiais
    if carta_nome == "oitava_vida":
        estado_jogo["vidas"][jogador] = min(estado_jogo["vidas"][jogador] + 1, 7) # Limita a 7 vidas
        print(f"{jogador} usou A Oitava Vida e recuperou uma vida!")
    elif carta_nome == "miuadicao":
        oponente = "jogador2" if jogador == "jogador1" else "jogador1"
        bloqueio = random.choice(opcoes)
        estado_jogo["efeitos_ativos"][oponente]["miuadicao"] = {"bloqueio": bloqueio, "duracao_restante": propriedades["duração"]}
        print(f"{jogador} usou Miuadição! {oponente} não pode usar {bloqueio} por {propriedades['duração']} turnos.")
    elif carta_nome == "carta_nulo":
        oponente = "jogador2" if jogador == "jogador1" else "jogador1"
        estado_jogo["efeitos_ativos"][oponente]["carta_nulo"] = {"duracao_restante": "partida"} # Dura a partida toda
        print(f"{jogador} usou Carta Nula! {oponente} não pode usar cartas especiais pelo resto da partida.")
    elif carta_nome == "pata_leve":
        # Esta carta é ativada APÓS o oponente jogar, mas ANTES de revelar
        # Precisaria de um pop-up ou prompt para o jogador trocar a jogada.
        # Por simplicidade, vamos tratar ela como um efeito que "prepara" para a troca.
        # Ou uma lógica que permita ao jogador apertar um botão para "trocar" a jogada.
        # Por enquanto, deixamos essa lógica para ser implementada no evento de KEYDOWN ou em uma fase específica.
        print(f"{jogador} usou Pata Leve! (Lógica de troca de jogada a ser implementada)")


def remover_efeitos_expirados():
    """Remove efeitos de cartas que expiraram."""
    global estado_jogo
    for jogador in ["jogador1", "jogador2"]:
        chaves_remover = []
        for carta_nome, efeito_data in estado_jogo["efeitos_ativos"][jogador].items():
            if "duracao_restante" in efeito_data and isinstance(efeito_data["duracao_restante"], int):
                efeito_data["duracao_restante"] -= 1
                if efeito_data["duracao_restante"] <= 0:
                    chaves_remover.append(carta_nome)
                    # Limpa mao_invencivel se Arranhão da Sorte expirar
                    if carta_nome == "arranhao_sorte":
                        if jogador == "jogador1": estado_jogo["mao_invencivel_j1"] = None
                        else: estado_jogo["mao_invencivel_j2"] = None
        for chave in chaves_remover:
            print(f"Efeito de {NOME_CARTAS_AMIGAVEL.get(chave, chave)} de {jogador} expirou.")
            del estado_jogo["efeitos_ativos"][jogador][chave]

def pode_jogar_mao(jogador, mao):
    """Verifica se o jogador pode jogar uma determinada mão, considerando efeitos de cartas."""
    efeitos = estado_jogo["efeitos_ativos"][jogador]
    if "miuadicao" in efeitos and efeitos["miuadicao"]["bloqueio"] == mao:
        return False
    return True

def processar_jogadas_teclado(key, jogador_num):
    """
    Processa a entrada do teclado para as jogadas dos jogadores.
    Retorna a jogada (pedra, papel, tesoura) ou None.
    """
    global estado_jogo
    teclas = teclas_jogador1 if jogador_num == 1 else teclas_jogador2
    jogada_var = "jogada_jogador1" if jogador_num == 1 else "jogada_jogador2"
    oponente_jogador = "jogador2" if jogador_num == 1 else "jogador1"

    if key in teclas:
        # Verifica se o oponente tem "Jogada do Hacker" ativa
        if "jogada_hacker" in estado_jogo["efeitos_ativos"][oponente_jogador]:
            # Troca a jogada aleatoriamente
            jogada_escolhida = random.choice(opcoes)
            print(f"Jogada do Hacker ativado! Jogador {jogador_num} tentou {teclas[key]}, mas jogou {jogada_escolhida}!")
        else:
            jogada_escolhida = teclas[key]

        if pode_jogar_mao(f"jogador{jogador_num}", jogada_escolhida):
            estado_jogo[jogada_var] = jogada_escolhida
        else:
            print(f"Jogador {jogador_num} tentou jogar {jogada_escolhida}, mas está bloqueado por Miuadição!")
            estado_jogo[jogada_var] = None # Garante que a jogada não é considerada
        return estado_jogo[jogada_var]
    return None

def processar_uso_carta(key, jogador_num):
    """
    Processa o uso de cartas especiais pelos jogadores.
    Retorna True se uma carta foi usada, False caso contrário.
    """
    global estado_jogo
    cartas_jogador_list = estado_jogo[f"cartas_jogador{jogador_num}"]
    jogador_str = f"jogador{jogador_num}"
    oponente_str = f"jogador{2 if jogador_num == 1 else 1}"

    # Não pode usar carta se Carta Nula estiver ativa no próprio jogador
    if "carta_nulo" in estado_jogo["efeitos_ativos"][jogador_str]:
        print(f"Jogador {jogador_num} não pode usar cartas! Carta Nula está ativa.")
        return False

    if (key == pygame.K_q and jogador_num == 1) or \
       (key == pygame.K_m and jogador_num == 2):
        if cartas_jogador_list:
            carta_usada = cartas_jogador_list.pop(0) # Pega a primeira carta
            aplicar_efeito_carta(jogador_str, carta_usada)
            return True
    return False

def calcular_resultado_rodada():
    """
    Calcula o resultado da rodada considerando as jogadas e efeitos de cartas.
    Retorna o vencedor ('jogador1', 'jogador2', 'empate') ou None se jogadas incompletas.
    """
    global estado_jogo

    j1_jogada = estado_jogo["jogada_jogador1"]
    j2_jogada = estado_jogo["jogada_jogador2"]

    if not j1_jogada or not j2_jogada:
        return None # Jogadas ainda não foram feitas

    vencedor = None
    vidas_perdidas = 1 # Padrão

    # Verificar Arranhão da Sorte primeiro (invencibilidade)
    if estado_jogo["mao_invencivel_j1"] == j1_jogada:
        vencedor = "jogador1"
        print(f"Arranhão da Sorte do Jogador 1 ativado! {j1_jogada} é invencível.")
    elif estado_jogo["mao_invencivel_j2"] == j2_jogada:
        vencedor = "jogador2"
        print(f"Arranhão da Sorte do Jogador 2 ativado! {j2_jogada} é invencível.")
    elif j1_jogada == j2_jogada:
        vencedor = "empate"
    elif (j1_jogada == "pedra" and j2_jogada == "tesoura") or \
         (j1_jogada == "papel" and j2_jogada == "pedra") or \
         (j1_jogada == "tesoura" and j2_jogada == "papel"):
        vencedor = "jogador1"
    else:
        vencedor = "jogador2"

    # Aplicar efeito Garra Feroz APÓS determinar o vencedor
    if vencedor != "empate":
        if "garra_feroz" in estado_jogo["efeitos_ativos"][vencedor]:
            vidas_perdidas = 2
            print(f"Garra Feroz ativada! {vencedor} causou dano duplo.")

    # Atualizar vidas se não for empate
    if vencedor == "jogador1":
        estado_jogo["vidas"]["jogador2"] -= vidas_perdidas
    elif vencedor == "jogador2":
        estado_jogo["vidas"]["jogador1"] -= vidas_perdidas

    return vencedor

def avancar_rodada():
    """Atualiza o estado do jogo para a próxima rodada."""
    global estado_jogo
    
    # Só avança a rodada se não for empate
    j1_jogada = estado_jogo["jogada_jogador1"]
    j2_jogada = estado_jogo["jogada_jogador2"]
    if j1_jogada and j2_jogada and j1_jogada != j2_jogada:
        estado_jogo["rodada"] += 1
    # Sorteia cartas nas rodadas 1, 5 e 9 (se quiser outras rodadas, mude aqui)
    if estado_jogo["rodada"] in [1, 5, 9]:
        estado_jogo["cartas_jogador1"].append(sortear_carta())
        estado_jogo["cartas_jogador2"].append(sortear_carta())

    # Zera jogadas para próxima rodada
    estado_jogo["jogada_jogador1"] = None
    estado_jogo["jogada_jogador2"] = None

    # Verifica condição de fim de jogo por vidas ou limite de rodadas
    if estado_jogo["vidas"]["jogador1"] <= 0:
        estado_jogo["vencedor_final"] = "Jogador 2"
        estado_jogo["modo"] = "fim_jogo"
    elif estado_jogo["vidas"]["jogador2"] <= 0:
        estado_jogo["vencedor_final"] = "Jogador 1"
        estado_jogo["modo"] = "fim_jogo"
    elif estado_jogo["rodada"] > estado_jogo["MAX_PARTIDAS"]:
        # Caso chegue ao fim das rodadas, o que tiver mais vida vence
        if estado_jogo["vidas"]["jogador1"] > estado_jogo["vidas"]["jogador2"]:
            estado_jogo["vencedor_final"] = "Jogador 1"
        elif estado_jogo["vidas"]["jogador2"] > estado_jogo["vidas"]["jogador1"]:
            estado_jogo["vencedor_final"] = "Jogador 2"
        else:
            estado_jogo["vencedor_final"] = "Empate!" # Ou um critério de desempate
        estado_jogo["modo"] = "fim_jogo"


def resetar_jogo():
    """Reseta todas as variáveis de estado do jogo para o início."""
    global estado_jogo
    estado_jogo = {
        "vidas": {"jogador1": 7, "jogador2": 7},
        "rodada": 1,
        "MAX_PARTIDAS": 13,
        "modo": None, # Começa no menu
        "jogada_jogador1": None,
        "jogada_jogador2": None,
        "mostrar_jogadas": False,
        "mostrar_jogadas_tempo": 0,
        "mensagem_tela": "Escolha o modo: 1 - Jogar contra CPU | 2 - Jogar Local",
        "vencedor_final": None,
        "cartas_jogador1": [],
        "cartas_jogador2": [],
        "efeitos_ativos": {"jogador1": {}, "jogador2": {}},
        "mao_invencivel_j1": None,
        "mao_invencivel_j2": None
    }
    # Sorteia as primeiras cartas ao resetar, se a rodada inicial (1) tiver sorteio
    if 1 in [1, 5, 9]: # Checa se a rodada 1 está na lista de sorteio
        estado_jogo["cartas_jogador1"].append(sortear_carta())
        estado_jogo["cartas_jogador2"].append(sortear_carta())


# --- 6. Loop Principal do Jogo ---
def game_loop():
    global estado_jogo # Permite modificar o dicionário global

    rodando = True
    clock = pygame.time.Clock()

    # Sorteia as primeiras cartas assim que o jogo inicia (ou no reset)
    # Isso garante que jogadores comecem com cartas, se rodada 1 for uma rodada de sorteio
    if 1 in [1, 5, 9]:
        estado_jogo["cartas_jogador1"].append(sortear_carta())
        estado_jogo["cartas_jogador2"].append(sortear_carta())


    while rodando:
        delta_time = clock.tick(60) / 1000.0 # Tempo em segundos desde o último frame

        # --- Gerenciamento de Eventos ---
        for evento in pygame.event.get():
            if evento.type == pygame.QUIT:
                rodando = False
            elif evento.type == pygame.KEYDOWN:
                if estado_jogo["modo"] == None: # Menu principal
                    if evento.key == pygame.K_1:
                        estado_jogo["modo"] = "cpu"
                        estado_jogo["mensagem_tela"] = "Modo CPU selecionado! Use A, S, D para jogar."
                    elif evento.key == pygame.K_2:
                        estado_jogo["modo"] = "local"
                        estado_jogo["mensagem_tela"] = "Modo Local selecionado! P1: A,S,D | P2: ←,↑,→"

                elif estado_jogo["modo"] in ["cpu", "local"]: # Jogo ativo
                    if not estado_jogo["mostrar_jogadas"]: # Só captura inputs se as jogadas não estiverem sendo mostradas
                        # Jogador 1 (sempre humano)
                        if estado_jogo["jogada_jogador1"] is None: # Só captura se não tiver jogado ainda
                            processar_jogadas_teclado(evento.key, 1)
                            if estado_jogo["modo"] == "cpu" and estado_jogo["jogada_jogador1"]:
                                # CPU joga automaticamente após o J1
                                estado_jogo["jogada_jogador2"] = random.choice(opcoes)
                                # Verifica se a jogada da CPU foi bloqueada por miuadição
                                if not pode_jogar_mao("jogador2", estado_jogo["jogada_jogador2"]):
                                    print("Jogada da CPU bloqueada por Miuadição!")
                                    estado_jogo["jogada_jogador2"] = None # A CPU não consegue jogar, resetamos a jogada

                        # Jogador 2 (apenas se for modo local)
                        if estado_jogo["modo"] == "local" and estado_jogo["jogada_jogador2"] is None:
                            processar_jogadas_teclado(evento.key, 2)


                        # Uso de Cartas
                        processar_uso_carta(evento.key, 1) # Jogador 1
                        if estado_jogo["modo"] == "local":
                            processar_uso_carta(evento.key, 2) # Jogador 2 (se for local)

                        # Se ambos os jogadores fizeram suas jogadas, mostrar resultados
                        if estado_jogo["jogada_jogador1"] and estado_jogo["jogada_jogador2"]:
                            estado_jogo["mostrar_jogadas"] = True
                            estado_jogo["mostrar_jogadas_tempo"] = pygame.time.get_ticks()

                elif estado_jogo["modo"] == "fim_jogo": # Tela de fim de jogo
                    if evento.key == pygame.K_r:
                        resetar_jogo()
                    elif evento.key == pygame.K_ESCAPE:
                        rodando = False

        # --- Atualização do Estado do Jogo ---
        if estado_jogo["modo"] in ["cpu", "local"]:
            if estado_jogo["mostrar_jogadas"]:
                # Se as jogadas estão sendo mostradas, esperar 3 segundos e então processar
                if pygame.time.get_ticks() - estado_jogo["mostrar_jogadas_tempo"] >= 3000:
                    estado_jogo["mostrar_jogadas"] = False
                    
                    # Calcular o resultado e atualizar vidas
                    vencedor_rodada = calcular_resultado_rodada()
                    
                    # Remover efeitos expirados ANTES de avançar a rodada para que o cálculo da rodada atual seja correto
                    remover_efeitos_expirados() # Movemos para cá
                    
                    print(f"Vencedor da rodada: {vencedor_rodada if vencedor_rodada else 'Nenhum'} - Vidas J1: {estado_jogo['vidas']['jogador1']}, Vidas J2: {estado_jogo['vidas']['jogador2']}")
                    
                    avancar_rodada() # Avança rodada, verifica fim de jogo, etc.

        # --- Desenho (Renderização) ---
        TELA.fill((255, 255, 255)) # Limpa a tela a cada frame

        if estado_jogo["modo"] == None:
            desenhar_menu(estado_jogo)
        elif estado_jogo["modo"] in ["cpu", "local"]:
            desenhar_hud(estado_jogo)
            if estado_jogo["mostrar_jogadas"]: # Mostra as jogadas se for o momento
                desenhar_jogadas_no_jogo(estado_jogo)
            else: # Caso contrário, exibe o background ou indicador de espera
                 # Aqui você pode desenhar algo que indique que o jogo está esperando inputs
                 # Por exemplo, um texto "Aguardando jogadas..."
                 pass # Ou deixe em branco para ver o HUD e as mãos vazias
        elif estado_jogo["modo"] == "fim_jogo":
            desenhar_tela_fim_jogo(estado_jogo)

        pygame.display.update() # Atualiza a tela

    pygame.quit()
    exit() # Garante que o programa é encerrado após pygame.quit()

# --- Ponto de Entrada Principal ---
if __name__ == "__main__":
    game_loop()
